<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scelta: scelta</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">scelta
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">scelta </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p><b>C++17 zero-overhead syntactic sugar for <code>variant</code> and <code>optional</code>.</b> </p>
</blockquote>
<p><a href="https://travis-ci.org/SuperV1234/scelta"></a> <a href="http://github.com/badges/stability-badges"></a> <a href="https://github.com/SuperV1234/scelta/blob/master/LICENSE"></a> <a href="https://gratipay.com/~SuperV1234/"></a> <a href="https://www.conan.io/source/scelta/0.1/SuperV1234/experimental"></a> </p><div class="image">
<img src="https://img.shields.io/badge/c++-17-ff69b4.svg?style=flat-square" alt="badge.cpp"/>
</div>
<h2>Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#installationusage">Installation/usage</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#resources">Resources</a></li>
</ul>
<h2>Overview</h2>
<p><code>std::variant</code> and <code>std::optional</code> were introduced to C++17's Standard Library. They are <b>sum types</b> that can greatly improve <em>type safety</em> and <em>performance</em>.</p>
<p>However, there are some problems with them:</p>
<ul>
<li>The syntax of some common operations such as <b>visitation</b> is not as nice as it could be, and requires a significant amount of boilerplate.</li>
<li>Defining and using recursive <code>variant</code> or <code>optional</code> types is not trivial and requires a lot of boilerplate.</li>
<li><code>std::optional</code> doesn't support visitation.</li>
<li>The interface of <code>std::variant</code> and <code>std::optional</code> is different from some other commonly used ADT implementations - interoperability requires significant boilerplate.</li>
</ul>
<p>**<code>scelta</code>** aims to fix all the aformenetioned problems by providing zero-overhead syntactic sugar that:</p>
<ul>
<li>Automatically detects and homogenizes all available <code>variant</code> and <code>optional</code> implementations, providing a single <b>implementation-independent</b> interface.</li>
<li>Provides **"pattern matching"**-like syntax for visitation and recursive visitation which works both for <code>variant</code> and <code>optional</code>.</li>
<li>Provides an intuitive <b>placeholder-based</b> recursive <code>variant</code> and <code>optional</code> type definition.</li>
</ul>
<h3>Implementation independent</h3>
<p><code>scelta</code> detects and works out-of-the-box with:</p>
<ul>
<li><code>std::variant</code></li>
<li><code>boost::variant</code></li>
<li><code>mpark::variant</code></li>
<li><code>eggs::variant</code></li>
<li><code>type_safe::variant</code></li>
<li><code>std::optional</code></li>
<li><code>boost::optional</code></li>
<li><code>type_safe::optional</code></li>
</ul>
<p>Other implementation can be easily adapted by providing specializations of the helper <code>traits</code> structs. PRs are welcome!</p>
<h3>Curried visitation syntax</h3>
<p><code>scelta</code> provides <em>curried</em>, <code>constexpr</code>-friendly, and SFINAE-friendly visitation utilities both for <code>variant</code> and <code>optional</code>. The final user syntax resembles <em>pattern matching</em>. Recursive data structures are supported.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> shape = std::variant&lt;circle, box&gt;;</div><div class="line"></div><div class="line">shape s0{circle{<span class="comment">/*...*/</span>}};</div><div class="line">shape s1{box{<span class="comment">/*...*/</span>}};</div><div class="line"></div><div class="line"><span class="comment">// In place `match` visitation.</span></div><div class="line">scelta::match([](circle, circle){ <span class="comment">/* ... */</span> },</div><div class="line">              [](circle, box)   { <span class="comment">/* ... */</span> },</div><div class="line">              [](box,    circle){ <span class="comment">/* ... */</span> },</div><div class="line">              [](box,    box)   { <span class="comment">/* ... */</span> })(s0, s1);</div></div><!-- fragment --><p>The <code>match</code> function is intentionally <em>curried</em> in order to allow reuse of a particular visitor in a scope, even on different implementations of <code>variant</code>/<code>optional</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> boost_optstr = boost::optional&lt;std::string&gt;;</div><div class="line"><span class="keyword">using</span> std_optstr = std::optional&lt;std::string&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Curried `match` usage.</span></div><div class="line"><span class="keyword">auto</span> print = scelta::match([](std::string s)    { cout &lt;&lt; s;       },</div><div class="line">                           [](<a class="code" href="structscelta_1_1nullopt__t.html">scelta::nullopt_t</a>){ cout &lt;&lt; <span class="stringliteral">&quot;empty&quot;</span>; });</div><div class="line"></div><div class="line">boost_optstr s0{<span class="comment">/*...*/</span>};</div><div class="line">std_optstr s1{<span class="comment">/*...*/</span>};</div><div class="line"></div><div class="line"><span class="comment">// Implementation-independent visitation.</span></div><div class="line">print(s0);</div><div class="line">print(s1);</div></div><!-- fragment --><h3>Recursive ADTs creation and visitation</h3>
<p>Recursive <code>variant</code> and <code>optional</code> data structures can be easily created through the use of <em>placeholders</em>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>impl</div><div class="line">{</div><div class="line">    <span class="keyword">namespace </span>sr = <a class="code" href="namespacescelta_1_1recursive.html">scelta::recursive</a>;</div><div class="line"></div><div class="line">    <span class="comment">// `placeholder` and `builder` can be used to define recursive</span></div><div class="line">    <span class="comment">// sum types.</span></div><div class="line">    <span class="keyword">using</span> _ = sr::placeholder;</div><div class="line">    <span class="keyword">using</span> builder = sr::builder&lt;std::variant&lt;int, std::vector&lt;_&gt;&gt;&gt;;</div><div class="line"></div><div class="line">    <span class="comment">// `type` evaluates to the final recursive data structure type.</span></div><div class="line">    <span class="keyword">using</span> type = sr::type&lt;builder&gt;;</div><div class="line"></div><div class="line">    <span class="comment">// `resolve` completely evaluates one of the alternatives.</span></div><div class="line">    <span class="comment">// (In this case, even the `Allocator` template parameter is</span></div><div class="line">    <span class="comment">// resolved!)</span></div><div class="line">    <span class="keyword">using</span> vector_type = sr::resolve&lt;builder, std::vector&lt;_&gt;&gt;;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">using</span> int_tree = impl::type;</div><div class="line"><span class="keyword">using</span> int_tree_vector = impl::vector_type;</div></div><!-- fragment --><p>After defining recursive structures, <em>in place recursive visitation</em> is also possible.</p>
<div class="fragment"><div class="line">int_tree t0{<span class="comment">/*...*/</span>};</div><div class="line"></div><div class="line">scelta::recursive::match&lt;return_type&gt;(</div><div class="line">    <span class="comment">// Base case.</span></div><div class="line">    [](<span class="keyword">auto</span>, <span class="keywordtype">int</span> x){ cout &lt;&lt; x; },</div><div class="line"></div><div class="line">    <span class="comment">// Recursive case.</span></div><div class="line">    [](<span class="keyword">auto</span> recurse, int_tree_vector v){ <span class="keywordflow">for</span>(<span class="keyword">auto</span> x : v) recurse(v); }</div><div class="line">)(t0);</div></div><!-- fragment --><h2>Installation/usage</h2>
<h3>Quick start</h3>
<p>**<code>scelta</code>** is an <em>header-only</em> library. It is sufficient to include it.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="preprocessor">#include &lt;scelta.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { <span class="keywordflow">return</span> 0; }</div></div><!-- fragment --><div class="fragment"><div class="line">g++ -std=c++1z main.cpp -Isome_path/scelta/include</div></div><!-- fragment --><h3>Running tests and examples</h3>
<p>Tests can be easily built and run using <a href="https://cmake.org/">CMake</a>.</p>
<div class="fragment"><div class="line">git clone https://github.com/SuperV1234/scelta &amp;&amp; cd scelta</div><div class="line">./init-repository.sh # get `vrm_cmake` dependency</div><div class="line">mkdir build &amp;&amp; cd build</div><div class="line"></div><div class="line">cmake ..</div><div class="line">make check # build and run tests</div><div class="line"></div><div class="line">make example_error_handling # error handling via pattern matching</div><div class="line">make example_expression     # recursive expression evaluation</div></div><!-- fragment --><p>All tests currently pass on <code>Arch Linux x64</code> with:</p>
<ul>
<li><code>g++ (GCC) 8.0.0 20170514 (experimental)</code></li>
<li><code>clang version 5.0.0 (trunk 303617)</code></li>
</ul>
<h3>Integration with existing project</h3>
<ol type="1">
<li><p class="startli">Add this repository and <a href="https://github.com/SuperV1234/vrm_cmake">SuperV1234/vrm_cmake</a> as submodules of your project, in subfolders inside <code>your_project/extlibs/</code>:</p>
<p class="startli">```bash git submodule add <a href="https://github.com/SuperV1234/vrm_cmake.git">https://github.com/SuperV1234/vrm_cmake.git</a> your_project/extlibs/vrm_cmake git submodule add <a href="https://github.com/SuperV1234/scelta.git">https://github.com/SuperV1234/scelta.git</a> your_project/extlibs/scelta ```</p>
</li>
<li><p class="startli">Include <code>vrm_cmake</code> in your project's <code>CMakeLists.txt</code> and look for the <code>scelta</code> extlib:</p>
<p class="startli">``<code>cmake &lt;h1&gt;Include</code>vrm_cmake`: list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/extlibs/vrm_cmake/cmake/") include(vrm_cmake)</p>
</li>
</ol>
<h1>Find <code>scelta</code>:</h1>
<p>vrm_cmake_find_extlib(scelta) ```</p>
<h2>Documentation</h2>
<h3><code>scelta::visit</code></h3>
<p>Executes non-recursive visitation.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename Visitor, typename... Visitables&gt; constexpr /*deduced*/ visit(Visitor&amp;&amp; visitor, Visitables&amp;&amp;... visitables) noexcept(/*deduced*/); ```</p><ul>
<li><code>visitables...</code> must all be the same type. *(i.e. different implementations of variant/optional currently cannot be mixed together)*</li>
<li><code>visitor</code> must be invocable with all the alternatives of the passed visitables.</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp struct visitor { auto operator()(int) { return 0; } auto operator()(char){ return 1; } };</p>
<p class="startli">variant&lt;int, char&gt; v0{'a'}; assert( scelta::visit(visitor{}, v0) == 1 ); ```</p>
<p class="startli">```cpp struct visitor { auto operator()(int) { return 0; } auto operator()(scelta::nullopt_t){ return 1; } };</p>
<p class="startli">optional&lt;int&gt; o0{0}; assert( scelta::visit(visitor{}, o0) == 0 ); ```</p>
</li>
</ul>
<h3><code>scelta::match</code></h3>
<p>Executes non-recursive in-place visitation.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename... FunctionObjects&gt; constexpr /*deduced*/ match(FunctionObjects&amp;&amp;... functionObjects) noexcept(/*deduced*/) { return <a href="auto&amp;&amp;... visitables">o = overload(functionObjects...)</a> noexcept(/*deduced*/) -&gt; /*deduced*/ { // ... perform visitation with <code>scelta::visit</code> ... }; }; ```</p><ul>
<li>Invoking <code>match</code> takes a number of <code>functionObjects...</code> and returns a new function which takes a number of <code>visitables...</code>.</li>
<li><code>visitables...</code> must all be the same type. *(i.e. different implementations of variant/optional currently cannot be mixed together)*</li>
<li><code>o</code> must be invocable with all the alternatives of the passed visitables. *(i.e. the overload of all <code>functionObjects...</code> must produce an exhaustive visitor)*</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp variant&lt;int, char&gt; v0{'a'}; assert( scelta::match([](int) { return 0; } [](char){ return 1; })(v0) == 1 ); ```</p>
<p class="startli">```cpp optional&lt;int&gt; o0{0}; assert( scelta::match([](int) { return 0; } [](<a class="el" href="structscelta_1_1nullopt__t.html">scelta::nullopt_t</a>){ return 1; })(o0) == 1 ); ```</p>
</li>
</ul>
<h3><code><a class="el" href="classscelta_1_1recursive_1_1builder.html">scelta::recursive::builder</a></code></h3>
<p>Allows placeholder-based definition of recursive ADTs.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename adt&gt;=""&gt; class builder;</p>
<p class="startli">struct placeholder;</p>
<p class="startli">template &lt;typename builder&gt;=""&gt; using type = /* ... recursive ADT type wrapper ... */;</p>
<p class="startli">template &lt;typename Builder, typename T&gt; using resolve = /* ... resolved ADT alternative ... */; ```</p><ul>
<li><code>builder</code> takes any ADT containing zero or more <code>placeholder</code> alternatives. *(i.e. both optional and variant)*</li>
<li><code>placeholder</code> is replaced with the recursive ADT itself when using <code>type</code> or <code>resolve</code>.</li>
<li><code>type</code> returns a wrapper around a fully-resolved recursive <code>ADT</code>.</li>
<li><code>resolve</code> returns a fully-resolved alternative contained in <code>ADT</code>.</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp using _ = <a class="el" href="structscelta_1_1recursive_1_1placeholder.html">scelta::recursive::placeholder</a>; using b = <a class="el" href="classscelta_1_1recursive_1_1builder.html">scelta::recursive::builder</a>&lt;variant&lt;int, _*&gt;&gt;;</p>
<p class="startli">using recursive_adt = scelta::recursive::type&lt;b&gt;; using ptr_alternative = scelta::recursive::resolve&lt;b, _*&gt;;</p>
<p class="startli">recursive_adt v0{0}; recursive_adt v1{&amp;v0}; ```</p>
</li>
</ul>
<h3><code>scelta::recursive::visit</code></h3>
<p>Executes recursive visitation.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename Return, typename Visitor, typename... Visitables&gt; constexpr Return visit(Visitor&amp;&amp; visitor, Visitables&amp;&amp;... visitables) noexcept(false); ```</p><ul>
<li>Similar to <code>scelta::match</code>, but requires an explicit return type and is not <code>noexcept</code>-friendly.</li>
<li>The <code>operator()</code> overloads of <code>visitor...</code> must take one extra generic argument to receive the <code>recurse</code> helper.</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp using _ = <a class="el" href="structscelta_1_1recursive_1_1placeholder.html">scelta::recursive::placeholder</a>; using b = <a class="el" href="classscelta_1_1recursive_1_1builder.html">scelta::recursive::builder</a>&lt;variant&lt;int, std::vector&lt;_&gt;&gt;&gt;;</p>
<p class="startli">using recursive_adt = scelta::recursive::type&lt;b&gt;; using rvec = scelta::recursive::resolve&lt;b, std::vector&lt;_&gt;&gt;;</p>
<p class="startli">struct visitor { auto operator()(auto,         int x) { /* base case */ }, auto operator()(auto recurse, rvec&amp; v){ for(auto&amp; x : v) recurse(x); } };</p>
<p class="startli">recursive_adt v0{rvec{recursive_adt{0}, recursive_adt{1}}}; scelta::recursive::visit(visitor{}, v0}; ```</p>
</li>
</ul>
<h3><code>scelta::recursive::match</code></h3>
<p>Executes recursive visitation.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename Return, typename... FunctionObjects&gt; constexpr auto match(FunctionObjects&amp;&amp;... functionObjects) noexcept(false) { return <a href="auto&amp;&amp;... visitables">o = overload(functionObjects...)</a> noexcept(false) -&gt; Return { // ... perform visitation with <code>scelta::recursive::visit</code> ... }; }; ```</p><ul>
<li>Similar to <code>scelta::visit</code>, but requires an explicit return type and is not <code>noexcept</code>-friendly.</li>
<li>The passed <code>functionObjects...</code> must take one extra generic argument to receive the <code>recurse</code> helper.</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp using _ = <a class="el" href="structscelta_1_1recursive_1_1placeholder.html">scelta::recursive::placeholder</a>; using b = <a class="el" href="classscelta_1_1recursive_1_1builder.html">scelta::recursive::builder</a>&lt;variant&lt;int, std::vector&lt;_&gt;&gt;&gt;;</p>
<p class="startli">using recursive_adt = scelta::recursive::type&lt;b&gt;; using rvec = scelta::recursive::resolve&lt;b, std::vector&lt;_&gt;&gt;;</p>
<p class="startli">recursive_adt v0{rvec{recursive_adt{0}, recursive_adt{1}}}; scelta::recursive::match( [](auto, int x) { /* base case */ }, [](auto recurse, rvec&amp; v){ for(auto&amp; x : v) recurse(x); } )(v0); ```</p>
</li>
</ul>
<h3><code>scelta::experimental::match</code></h3>
<p>**(work-in-progress)**</p>
<p>Executes visitation *(both non-recursive and recursive)*. Attempts to deduce the return type from the base cases, optionally supports user-provided explicit return type.</p>
<ul>
<li><p class="startli">Interface:</p>
<p class="startli">```cpp template &lt;typename Return = impl::deduce_t, typename... BaseCases&gt; constexpr auto match(BaseCases&amp;&amp;... baseCases) { return <a href="auto... xs">bco = overload(adapt(baseCases)...)</a> { if constexpr(are_visitables&lt;decltype(xs)...&gt;()) { // ... perform visitation with <code>scelta::visit</code> ... } else { return <a href="auto&amp;&amp;... visitables">o = overload(bco, xs...)</a> { // ... perform visitation with <code>scelta::recursive_visit</code> ... }; } }; }; ```</p><ul>
<li>The first invocation of <code>scelta::experimental::match</code> takes one or more <em>base cases</em>. A base case is a function object with the same arity as the number of objects that will be visited.</li>
<li>The function returned by the first invocation takes either a number of <em>recursive cases</em> or a number of <em>visitables</em>.<ul>
<li>Recursive cases are function objects with arity equal to the number of objects that will be visited plus one *(the +1 is for the <code>recurse</code> argument)*.</li>
<li>Visitables are variants or optionals. If visitables are passed here, non-recursive visitation will be performed immediately.</li>
</ul>
</li>
<li>If recursive cases were passed, the last returned function takes any number of visitables. Recursive visitation will then be performed immediately.</li>
</ul>
</li>
<li><p class="startli">Examples:</p>
<p class="startli">```cpp variant&lt;int, char&gt; v0{'a'}; assert( scelta::experimental::match([](int) { return 0; } [](char){ return 1; })(v0) == 1 ); ```</p>
<p class="startli">```cpp using _ = <a class="el" href="structscelta_1_1recursive_1_1placeholder.html">scelta::recursive::placeholder</a>; using b = <a class="el" href="classscelta_1_1recursive_1_1builder.html">scelta::recursive::builder</a>&lt;variant&lt;int, std::vector&lt;_&gt;&gt;&gt;;</p>
<p class="startli">using recursive_adt = scelta::recursive::type&lt;b&gt;; using rvec = scelta::recursive::resolve&lt;b, std::vector&lt;_&gt;&gt;;</p>
<p class="startli">recursive_adt v0{rvec{recursive_adt{0}, recursive_adt{1}}}; scelta::experimental::match( [](int x){ /* base case */ } )( [](auto recurse, rvec&amp; v){ for(auto&amp; x : v) recurse(x); } )(v0); ```</p>
</li>
</ul>
<h2>Resources</h2>
<ul>
<li>ACCU 2017 talk: <a href="https://www.youtube.com/watch?v=mqei4JJRQ7s">**"Implementing variant Visitation Using Lambdas"**</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
